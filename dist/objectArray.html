<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content=" " name="description">
    <meta content=" " name="keywords">

    <link href="css/style.css" rel="stylesheet">

    <title>Анализ производительности массивов и объектов</title>
</head>
<body>

<h1>Анализ производительности массивов и объектов</h1>

<h2>Когда использовать объекты</h2>
<ol>
    <li>
        <p>Когда вам не нужен порядок</p>
        <p>Но вы не можете вставить в начало, середину или конец объекта.</p>
        <p>объекты поставляются с такими вещами, как ключи, значения и записи. Все эти три являются O из n.</p>
    </li>

    <li>
        <p>Когда вам нужен быстрый доступ / вставка и удаление</p>
    </li>

    <li>
        <p>Большое количество объектов Когда вам не нужно никакого упорядочивания, объекты - отличный выбор!</p>
    </li>

    <li>
        <p>Вставка - O(1)</p>
    </li>

    <li>
        <p>Удаление - O(1)</p>
    </li>

    <li>
        <p>Поиск - O (N)</p>
    </li>

    <li>
        <p>Доступ - O(1)</p>
    </li>

    <li>
        <p>Большое количество объектных методов</p>
    </li>

    <li>
        <p>Object.keys - O(N)</p>
    </li>

    <li>
        <p>Object.values - O(N)</p>
    </li>

    <li>
        <p>Object.entries - O(N)</p>
    </li>

    <li>
        <p>hasOwnProperty - O(1)</p>
    </li>
</ol>

<h1>МАССИВЫ</h1>
<p>Упорядоченные списки!</p>
<p>Когда у вас есть массив из 10 000 элементов и вы запрашиваете 9000 элементов, допустим, JavaScript не работает.</p>
<p>Пройдите по каждому отдельному элементу, считая до 9000 и получая доступ к каждому элементу, а затем. Выбираем тот, который вам нужен, и предоставляем его вам.</p>
<p>Вы можете подумать, что есть прямой путь к каждому элементу, если у вас есть число, если у вас есть индекс и массив заходит так далеко, конечно, это единственное условие.
    Это допустимый индекс.
    Вы можете сразу перейти к данным.
    Таким образом, не имеет значения, какой длины массив.
    Не имеет значения, смотрите ли вы на последний элемент, средний элемент или на первый элемент.</p>

<strong>
    <xmp>
        let names = ["Michael", "Melissa", "Andrea"];

        let values = [true, {}, [], 2, "awesome"];
    </xmp>
</strong>

<h2>КОГДА ИСПОЛЬЗОВАТЬ МАССИВЫ</h2>
<ol>
    <li>
        <p>Когда вам нужен порядок</p>
    </li>

    <li>
        <p>Когда вам нужен быстрый доступ / вставка и удаление</p>
    </li>
    <li>
        <p>Поиск - O (N)</p>
    </li>

    <li>
        <p>Доступ - O(1)</p>
    </li>

    <li>
        <p>forEach/map/filter/reduce / etc. - O(N)</p>
    </li>

    <li>
        <p>push - O(1)</p>
    </li>

    <li>
        <p>pop - O(1)</p>
    </li>

    <li>
        <p>sort - O(N * log N)</p>
    </li>

    <li>
        <p>splice - O(N)</p>
    </li>

    <li>
        <p>slice - O(N)</p>
    </li>

    <li>
        <p>Вставить в начале не так просто, как мы могли бы подумать! Для этого существуют более эффективные структуры данных!</p>
    </li>
</ol>

</body>
</html>
